# 串行/并行/CMS/G1与堆内存总结
1.串行GC(SerialC):

    1.1 年轻代使用mark-copy(标记-复制)算法，老年代使用mark-sweep-compact(标记-清除-整理)算法。

    1.2 会导致STW（Stop-The World）。多核CPU不能充分利用，在垃圾收集时只会使用单核处理，只适合用于几百M堆内存的JVM，而且单核CPU时比较合适。

2.并行GC(ParallelGC):

    2.1 年轻代使用mark-copy(标记-复制)算法，老年代使用mark-sweep-compact(标记-清除-整理)算法。

    2.2 会导致STW（Stop-The World）。适用于多核CPU，由于对系统资源能更加有效利用，所以会有更高的吞吐量。在GC的时候，所有线程一起进行，不需要的时候，不消耗任何系统资源。但是不一定会减少GC的暂停时间。

3.CMSGC:

    3.1 年轻代使用mark-copy(标记-复制)算法，老年代使用mark-sweep(标记-清除)算法。

    3.2 不对老年代进行整理，而是使用空闲列表（free-lists）来管理内存空间的回收。

    3.3 在mark-sweep（标记-清除）阶段，大部分工作和应用线程并发执行，一般情况下，CMS使用的并发数默认为CPU核心数的1/4。

    3.4 响应时间优先，减少垃圾收集停顿时间，即GC暂停时间短。

    3.5 存在碎片化问题，在长时间运行的情况下会发生full GC，导致恶劣停顿。会占用更多的CPU资源，和用户争抢线程。

4.G1GC:

    4.1 堆不再划分年轻代和老年代，而是划分多个（通常为2048个）可以存放对象的小块堆区域。

    4.2 不必每次都收集整个堆空间，而是以增量的方式来处理，每次只处理一部分内存块。

    4.3 在并发的阶段估算每个小堆块存活对象的总数，优先收集垃圾最多的小块。
    
    4.4 支持很大的堆，高吞吐量，GC暂停时间短。

